//go:build linux

package dns

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// Configure configures DNS for the VPN interface (Linux).
func (m *Manager) Configure(cfg *Config) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.interfaceName = cfg.InterfaceName
	m.vpnDNS = cfg.Servers
	m.splitDNS = cfg.SplitDNS
	m.splitDomains = cfg.Domains

	m.saveOriginalDNS()

	if len(cfg.Servers) > 0 {
		if err := m.setDNS(cfg.InterfaceName, cfg.Servers, cfg.Domains); err != nil {
			return fmt.Errorf("failed to set DNS: %w", err)
		}
	}

	return nil
}

func (m *Manager) saveOriginalDNS() {
	// Try systemd-resolve
	cmd := exec.Command("resolvectl", "dns", m.interfaceName)
	out, err := cmd.Output()
	if err == nil {
		parts := strings.Fields(strings.TrimSpace(string(out)))
		if len(parts) > 0 {
			m.originalDNS = parts
		}
		return
	}

	// Fallback: read /etc/resolv.conf
	data, err := os.ReadFile("/etc/resolv.conf")
	if err != nil {
		return
	}
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "nameserver ") {
			m.originalDNS = append(m.originalDNS, strings.TrimPrefix(line, "nameserver "))
		}
	}
}

func (m *Manager) setDNS(interfaceName string, servers []string, domains []string) error {
	// Try systemd-resolved first
	args := append([]string{"dns", interfaceName}, servers...)
	cmd := exec.Command("resolvectl", args...)
	if _, err := cmd.CombinedOutput(); err == nil {
		// Set domains for split DNS
		if len(domains) > 0 {
			dArgs := append([]string{"domain", interfaceName}, domains...)
			exec.Command("resolvectl", dArgs...).CombinedOutput()
		}
		return nil
	}

	// Fallback: write /etc/resolv.conf
	var content strings.Builder
	content.WriteString("# Generated by VPN Client\n")
	for _, srv := range servers {
		content.WriteString(fmt.Sprintf("nameserver %s\n", srv))
	}
	return os.WriteFile("/etc/resolv.conf", []byte(content.String()), 0644)
}

// Reset restores original DNS configuration (Linux).
func (m *Manager) Reset() error {
	m.mu.Lock()
	defer m.mu.Unlock()

	if m.interfaceName != "" {
		// Try resolvectl revert
		cmd := exec.Command("resolvectl", "revert", m.interfaceName)
		if cmd.Run() == nil {
			m.originalDNS = nil
			return nil
		}
	}

	// Fallback: restore /etc/resolv.conf
	if len(m.originalDNS) > 0 {
		var content strings.Builder
		for _, srv := range m.originalDNS {
			content.WriteString(fmt.Sprintf("nameserver %s\n", srv))
		}
		os.WriteFile("/etc/resolv.conf", []byte(content.String()), 0644)
	}

	m.originalDNS = nil
	return nil
}

// FlushDNSCache flushes the DNS cache (Linux).
func (m *Manager) FlushDNSCache() error {
	cmd := exec.Command("resolvectl", "flush-caches")
	if err := cmd.Run(); err != nil {
		// Try systemd-resolve fallback
		cmd = exec.Command("systemd-resolve", "--flush-caches")
		cmd.Run()
	}
	return nil
}

// EnableDNSLeakProtection blocks DNS queries to non-VPN DNS servers (Linux â€” iptables).
func (m *Manager) EnableDNSLeakProtection(vpnDNS []string) error {
	m.DisableDNSLeakProtection()

	// Allow DNS to VPN servers
	for _, dns := range vpnDNS {
		exec.Command("iptables", "-A", "OUTPUT", "-p", "udp", "--dport", "53",
			"-d", dns, "-j", "ACCEPT").CombinedOutput()
	}

	// Block all other DNS
	exec.Command("iptables", "-A", "OUTPUT", "-p", "udp", "--dport", "53",
		"-j", "DROP").CombinedOutput()

	return nil
}

// DisableDNSLeakProtection removes DNS leak protection rules (Linux).
func (m *Manager) DisableDNSLeakProtection() error {
	exec.Command("iptables", "-D", "OUTPUT", "-p", "udp", "--dport", "53",
		"-j", "DROP").CombinedOutput()
	return nil
}
